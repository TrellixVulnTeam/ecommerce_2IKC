'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _lodash = require('lodash');

var _fp = require('lodash/fp');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function createSubstyle(closureProps) {
  function substyle(props, selectedKeys) {
    var style = (closureProps.style || props.style) && (0, _lodash.merge)({}, closureProps.style, props.style);
    var className = props.className || closureProps.className;

    if (Object.prototype.toString.call(selectedKeys) === '[object Function]') {
      selectedKeys = selectedKeys(props);
    }

    if (!selectedKeys) {
      selectedKeys = [];
    } else if (typeof selectedKeys === 'string') {
      selectedKeys = [selectedKeys];
    } else if (Object.prototype.toString.call(selectedKeys) === '[object Object]') {
      selectedKeys = (0, _lodash.keys)(selectedKeys).reduce(function (keys, key) {
        return keys.concat(selectedKeys[key] ? [key] : []);
      }, []);
    }

    (0, _invariant2.default)(Array.isArray(selectedKeys), 'Second parameter must be a string, an array of strings, a plain object with boolean ' + 'values, a falsy value, or a function with a return value of one of these four types.');

    var baseClassName = className && className.split(' ')[0];
    var toElementClassNames = (0, _fp.map)(function (key) {
      return baseClassName + '__' + key;
    });
    var toModifierClassNames = (0, _fp.map)(function (key) {
      return baseClassName + '--' + key.substring(1);
    });

    var modifierKeys = (0, _fp.filter)(isModifier, selectedKeys);
    var elementKeys = (0, _fp.filter)(isElement, selectedKeys);

    var collectElementStyles = elementKeys.length > 0 ? function (style) {
      return (0, _lodash.values)(pickNestedStyles(style, elementKeys));
    } : function (style) {
      return [style];
    };

    return createSubstyle(_extends({}, style && {
      style: _lodash.merge.apply(undefined, [{}].concat(_toConsumableArray(collectElementStyles(hoistModifierStylesRecursive(style, modifierKeys)))))
    }, className && {
      className: (elementKeys.length === 0 ? [className].concat(_toConsumableArray(toModifierClassNames(modifierKeys))) : toElementClassNames(elementKeys)).join(' ')
    }));
  }

  // assign `style` and/or `className` props to the return function object
  (0, _lodash.assign)(substyle, closureProps);
  return substyle;
}

exports.default = createSubstyle({});


var isModifier = function isModifier(key) {
  return key[0] === '&';
};
var isElement = (0, _lodash.negate)(isModifier);

var pickNestedStyles = function pickNestedStyles(style, keysToPick) {
  var camelizedKeysToPick = (0, _fp.map)(camelize, keysToPick);
  var styleKeys = (0, _lodash.keys)(style);
  var result = {};
  for (var i = 0, l = styleKeys.length; i < l; ++i) {
    var key = styleKeys[i];
    if (keysToPick.indexOf(key) >= 0 || camelizedKeysToPick.indexOf(camelize(key)) >= 0) {
      result[key] = style[key];
    }
  }
  return result;
};

// breadth-first hoisting of selected modifier style subtrees
// does not traverse into element, :pseudo-selector or @directive subtrees
var hoistModifierStylesRecursive = function hoistModifierStylesRecursive(style, modifierKeysToPick) {
  // hoist styles for selected modifiers on current level
  var result = _lodash.merge.apply(undefined, [(0, _lodash.omit)(style, modifierKeysToPick)].concat(_toConsumableArray((0, _lodash.values)(pickNestedStyles(style, modifierKeysToPick)))));

  // traverse nested styled for ALL modifiers
  var modifierKeys = (0, _fp.filter)(isModifier, (0, _lodash.keys)(result));
  for (var i = 0, l = modifierKeys.length; i < l; ++i) {
    var key = modifierKeys[i];
    var subresult = hoistModifierStylesRecursive(result[key], modifierKeysToPick);
    if (modifierKeysToPick.indexOf(key) >= 0) {
      // selected modifier: hoist subresult
      delete result[key];
      (0, _lodash.merge)(result, subresult);
    } else {
      // non-selected modifier: replace with subresult
      result[key] = subresult;
    }
  }
  return result;
};

var camelize = function camelize(key) {
  return key.replace(/-(\w)/g, function (m, c) {
    return c.toUpperCase();
  });
};
module.exports = exports['default'];